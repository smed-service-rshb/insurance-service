/*
 * API микросервиса управления договорами страхования
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ru.softlab.efr.services.insurance;

import ru.softlab.efr.services.insurance.model.rest.AcquiringFindByCodeRq;
import ru.softlab.efr.services.insurance.model.rest.AcquiringInsuranceRq;
import ru.softlab.efr.services.insurance.model.rest.AcquiringInsuranceRs;
import ru.softlab.efr.services.insurance.model.rest.AcquiringPaymentInfoRs;
import ru.softlab.efr.services.insurance.model.rest.AvailableProgramsRs;
import ru.softlab.efr.services.insurance.model.rest.ErrorModel;

import ru.softlab.efr.infrastructure.transport.client.*;
import ru.softlab.efr.common.utilities.rest.*;
import ru.softlab.efr.common.utilities.rest.client.*;
import ru.softlab.efr.common.utilities.rest.converters.DateParser;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import ru.softlab.efr.infrastructure.transport.client.impl.JmsUriBuilder;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.util.*;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Содержит методы для взаимодействия с приложением insurance-service
 **/
@Component
public class AcquiringContractClient {
    private static final String REQUIRED_PARAM_ERROR = "Не указан обязательный параметр '%s' при вызове %s";
    private String applicationName;
    private static final String STATUS_CODE_TEMPLATE = "status code: [%s]";

    private final MicroServiceTemplate microServiceTemplate;

    /**
     * Возвращяет экземпляр класса
     * @param microServiceTemplate - объект, реализующий интерфейс {@link MicroServiceTemplate}
     */
    public AcquiringContractClient(MicroServiceTemplate microServiceTemplate) {
        this.microServiceTemplate = microServiceTemplate;
        this.applicationName = "insurance-service";
    }


    /**
     * Найти информацию о договоре по коду, для оплаты в ЛК
     * POST /insurance-service/public/v2/contract/acquiring/findByCode
     *
     * @param body Запрос на получение информации о договоре по коду (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AcquiringInsuranceRs acquiringFindByCode(AcquiringFindByCodeRq body, long timeout) throws RestClientException {
        return acquiringFindByCode(body).get(timeout);
    }

    /**
     * Найти информацию о договоре по коду, для оплаты в ЛК асинхронно
     * POST /insurance-service/public/v2/contract/acquiring/findByCode
     *
     * @param body Запрос на получение информации о договоре по коду (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AcquiringInsuranceRs> acquiringFindByCode(AcquiringFindByCodeRq body) throws RestClientException {
        return new ClientRestResult<>(acquiringFindByCodeInternal(body), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AcquiringInsuranceRs>> acquiringFindByCodeInternal(AcquiringFindByCodeRq body) throws RestClientException {
        if (body == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "body", "acquiringFindByCode"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/findByCode"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(body);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AcquiringInsuranceRs>(){});
    }

    /**
     * Получение информации по оформлению договора через ЛК
     * GET /insurance-service/public/v2/contract/acquiring/info/{uuid}
     *
     * @param uuid Строковый идентификатор процесса оформления договора (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AcquiringInsuranceRs acquiringInfo(String uuid, long timeout) throws RestClientException {
        return acquiringInfo(uuid).get(timeout);
    }

    /**
     * Получение информации по оформлению договора через ЛК асинхронно
     * GET /insurance-service/public/v2/contract/acquiring/info/{uuid}
     *
     * @param uuid Строковый идентификатор процесса оформления договора (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AcquiringInsuranceRs> acquiringInfo(String uuid) throws RestClientException {
        return new ClientRestResult<>(acquiringInfoInternal(uuid), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AcquiringInsuranceRs>> acquiringInfoInternal(String uuid) throws RestClientException {
        if (uuid == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "uuid", "acquiringInfo"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/info/{uuid}")).variable("uuid", uuid);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AcquiringInsuranceRs>(){});
    }

    /**
     * Получение информации об оплате договора, оформленного через ЛК
     * GET /insurance-service/public/v2/contract/acquiring/info/{orderId}/order
     *
     * @param orderId Идентификатор экземпляра заказа на оплату договора страхования (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AcquiringPaymentInfoRs acquiringPaymentInfo(Long orderId, long timeout) throws RestClientException {
        return acquiringPaymentInfo(orderId).get(timeout);
    }

    /**
     * Получение информации об оплате договора, оформленного через ЛК асинхронно
     * GET /insurance-service/public/v2/contract/acquiring/info/{orderId}/order
     *
     * @param orderId Идентификатор экземпляра заказа на оплату договора страхования (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AcquiringPaymentInfoRs> acquiringPaymentInfo(Long orderId) throws RestClientException {
        return new ClientRestResult<>(acquiringPaymentInfoInternal(orderId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AcquiringPaymentInfoRs>> acquiringPaymentInfoInternal(Long orderId) throws RestClientException {
        if (orderId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "orderId", "acquiringPaymentInfo"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/info/{orderId}/order")).variable("orderId", orderId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AcquiringPaymentInfoRs>(){});
    }

    /**
     * Выполнить проверку возможности оформления договора КСП для клиента
     * POST /insurance-service/public/v2/contract/acquiring/check/ksp/client/{clientId}
     *
     * @param clientId Идентификатор клиента (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void checkExistKsp(Long clientId, long timeout) throws RestClientException {
        return checkExistKsp(clientId).get(timeout);
    }

    /**
     * Выполнить проверку возможности оформления договора КСП для клиента асинхронно
     * POST /insurance-service/public/v2/contract/acquiring/check/ksp/client/{clientId}
     *
     * @param clientId Идентификатор клиента (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> checkExistKsp(Long clientId) throws RestClientException {
        return new ClientRestResult<>(checkExistKspInternal(clientId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> checkExistKspInternal(Long clientId) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "checkExistKsp"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/check/ksp/client/{clientId}")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Получить список доступных для оформления клиентом программ страхования
     * GET /insurance-service/public/v2/contract/acquiring/programs
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AvailableProgramsRs getAvailableProgram(long timeout) throws RestClientException {
        return getAvailableProgram().get(timeout);
    }

    /**
     * Получить список доступных для оформления клиентом программ страхования асинхронно
     * GET /insurance-service/public/v2/contract/acquiring/programs
     *
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AvailableProgramsRs> getAvailableProgram() throws RestClientException {
        return new ClientRestResult<>(getAvailableProgramInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AvailableProgramsRs>> getAvailableProgramInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/programs"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AvailableProgramsRs>(){});
    }

    /**
     * Создание договора клиентом
     * POST /insurance-service/public/v2/contract/acquiring/issue
     *
     * @param request Запрос на оформление договора для покупки (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AcquiringInsuranceRs issueInsurance(AcquiringInsuranceRq request, long timeout) throws RestClientException {
        return issueInsurance(request).get(timeout);
    }

    /**
     * Создание договора клиентом асинхронно
     * POST /insurance-service/public/v2/contract/acquiring/issue
     *
     * @param request Запрос на оформление договора для покупки (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AcquiringInsuranceRs> issueInsurance(AcquiringInsuranceRq request) throws RestClientException {
        return new ClientRestResult<>(issueInsuranceInternal(request), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AcquiringInsuranceRs>> issueInsuranceInternal(AcquiringInsuranceRq request) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/issue"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(request);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AcquiringInsuranceRs>(){});
    }

    /**
     * Проверка возможности оформления договора клиентом
     * POST /insurance-service/public/v2/contract/acquiring/registration
     *
     * @param request Запрос на создание договора для покупки (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AcquiringInsuranceRs registrationAcquiring(AcquiringInsuranceRq request, long timeout) throws RestClientException {
        return registrationAcquiring(request).get(timeout);
    }

    /**
     * Проверка возможности оформления договора клиентом асинхронно
     * POST /insurance-service/public/v2/contract/acquiring/registration
     *
     * @param request Запрос на создание договора для покупки (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AcquiringInsuranceRs> registrationAcquiring(AcquiringInsuranceRq request) throws RestClientException {
        return new ClientRestResult<>(registrationAcquiringInternal(request), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AcquiringInsuranceRs>> registrationAcquiringInternal(AcquiringInsuranceRq request) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/public/v2/contract/acquiring/registration"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(request);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AcquiringInsuranceRs>(){});
    }
    private String cutComments(String path) {
        return path.split("#", 2)[0];
    }

    private void addPageableParams(MicroServiceURIBuilder builder, Pageable pageable) {
        if (pageable != null) {
            builder.param("page", pageable.getPageNumber());
            builder.param("size", pageable.getPageSize());
            Sort sort = pageable.getSort();
            if (sort != null) {
                List<String> sortParams = new ArrayList<>();
                for (Sort.Order next : sort) {
                    sortParams.add(next.getProperty());
                }
                sortParams.add(sort.getOrderFor(sortParams.get(0)).getDirection().name());
                builder.param("sort", String.join(",", sortParams));
            }
        }
    }

    private void processStatusCodeErrors(Exception e) throws RestClientException {
            HttpStatus statusCode = RestUtils.getStatusCode(e);
            if (statusCode != null) {
                switch (statusCode) {
                    case INTERNAL_SERVER_ERROR:
                        throw new RestClientException(String.format(STATUS_CODE_TEMPLATE, HttpStatus.INTERNAL_SERVER_ERROR.toString()));
                    case CONFLICT:
                        throw new EntityExistsException();
                    case NOT_FOUND:
                        throw new NotFoundException();
                }
            }
            throw new RestClientException(e.toString());
    }
}
