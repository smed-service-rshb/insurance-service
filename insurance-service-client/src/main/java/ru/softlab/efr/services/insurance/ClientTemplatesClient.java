/*
 * API микросервиса управления договорами страхования
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ru.softlab.efr.services.insurance;

import ru.softlab.efr.services.insurance.model.rest.ClientTemplateData;
import ru.softlab.efr.services.insurance.model.rest.ClientTemplateDataForList;
import ru.softlab.efr.services.insurance.model.rest.ClientTemplateList;
import ru.softlab.efr.services.insurance.model.rest.ErrorModel;
import ru.softlab.efr.services.insurance.model.rest.FilterClientTemplates;
import org.springframework.core.io.Resource;
import ru.softlab.efr.services.insurance.model.rest.UuidRs;

import ru.softlab.efr.infrastructure.transport.client.*;
import ru.softlab.efr.common.utilities.rest.*;
import ru.softlab.efr.common.utilities.rest.client.*;
import ru.softlab.efr.common.utilities.rest.converters.DateParser;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import ru.softlab.efr.infrastructure.transport.client.impl.JmsUriBuilder;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.util.*;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Содержит методы для взаимодействия с приложением insurance-service
 **/
@Component
public class ClientTemplatesClient {
    private static final String REQUIRED_PARAM_ERROR = "Не указан обязательный параметр '%s' при вызове %s";
    private String applicationName;
    private static final String STATUS_CODE_TEMPLATE = "status code: [%s]";

    private final MicroServiceTemplate microServiceTemplate;

    /**
     * Возвращяет экземпляр класса
     * @param microServiceTemplate - объект, реализующий интерфейс {@link MicroServiceTemplate}
     */
    public ClientTemplatesClient(MicroServiceTemplate microServiceTemplate) {
        this.microServiceTemplate = microServiceTemplate;
        this.applicationName = "insurance-service";
    }


    /**
     * Сохранить документ, прикладываеммый к записи справочника шаблонов и инструкций
     * POST /insurance-service/v1/attach/client-templates
     *
     * @param content файл в форматах pdf, jpeg, gif, с размером до 5Мб (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public UuidRs addTemplateContent(Resource content, long timeout) throws RestClientException {
        return addTemplateContent(content).get(timeout);
    }

    /**
     * Сохранить документ, прикладываеммый к записи справочника шаблонов и инструкций асинхронно
     * POST /insurance-service/v1/attach/client-templates
     *
     * @param content файл в форматах pdf, jpeg, gif, с размером до 5Мб (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<UuidRs> addTemplateContent(Resource content) throws RestClientException {
        return new ClientRestResult<>(addTemplateContentInternal(content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<UuidRs>> addTemplateContentInternal(Resource content) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/attach/client-templates"));

        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<UuidRs>(){});
    }

    /**
     * Создать запись в справочнике шаблонов заявлений и инструкций
     * POST /insurance-service/v1/client-templates
     *
     * @param body Данные записи справочника шаблонов заявлений и инструкций (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Сохраненная запись в справочнике.
     * @throws RestClientException в случае неудачи
    */
    public ClientTemplateData createClientTemplates(ClientTemplateData body, long timeout) throws RestClientException {
        return createClientTemplates(body).get(timeout);
    }

    /**
     * Создать запись в справочнике шаблонов заявлений и инструкций асинхронно
     * POST /insurance-service/v1/client-templates
     *
     * @param body Данные записи справочника шаблонов заявлений и инструкций (required)
     * @return Сохраненная запись в справочнике.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ClientTemplateData> createClientTemplates(ClientTemplateData body) throws RestClientException {
        return new ClientRestResult<>(createClientTemplatesInternal(body), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ClientTemplateData>> createClientTemplatesInternal(ClientTemplateData body) throws RestClientException {
        if (body == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "body", "createClientTemplates"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/client-templates"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(body);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ClientTemplateData>(){});
    }

    /**
     * Удалить файл, приложенный к записи справочника шаблонов и инструкций
     * DELETE /insurance-service/v1/attach/client-templates/{attachId}
     *
     * @param attachId Идентификатор файла (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void deleteTemplateContent(String attachId, long timeout) throws RestClientException {
        return deleteTemplateContent(attachId).get(timeout);
    }

    /**
     * Удалить файл, приложенный к записи справочника шаблонов и инструкций асинхронно
     * DELETE /insurance-service/v1/attach/client-templates/{attachId}
     *
     * @param attachId Идентификатор файла (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> deleteTemplateContent(String attachId) throws RestClientException {
        return new ClientRestResult<>(deleteTemplateContentInternal(attachId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> deleteTemplateContentInternal(String attachId) throws RestClientException {
        if (attachId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "attachId", "deleteTemplateContent"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/attach/client-templates/{attachId}")).variable("attachId", attachId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.DELETE, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Подучить данные по элементу справочника шаблонов заявлений и инструкций
     * GET /insurance-service/v1/client-templates/{id}
     *
     * @param id Идентификатор записи справочника шаблонов заявлений и инструкций (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Данные записи в справочнике.
     * @throws RestClientException в случае неудачи
    */
    public ClientTemplateData getClientTemplate(Long id, long timeout) throws RestClientException {
        return getClientTemplate(id).get(timeout);
    }

    /**
     * Подучить данные по элементу справочника шаблонов заявлений и инструкций асинхронно
     * GET /insurance-service/v1/client-templates/{id}
     *
     * @param id Идентификатор записи справочника шаблонов заявлений и инструкций (required)
     * @return Данные записи в справочнике.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ClientTemplateData> getClientTemplate(Long id) throws RestClientException {
        return new ClientRestResult<>(getClientTemplateInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ClientTemplateData>> getClientTemplateInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "getClientTemplate"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/client-templates/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ClientTemplateData>(){});
    }

    /**
     * Получить список шаблонов и инструкций актуальных для договора
     * GET /insurance-service/v1/consumers/client-templates/{insuranceId}
     *
     * @param insuranceId Идентификатор договора страхования (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientTemplateList getClientTemplates(Long insuranceId, long timeout) throws RestClientException {
        return getClientTemplates(insuranceId).get(timeout);
    }

    /**
     * Получить список шаблонов и инструкций актуальных для договора асинхронно
     * GET /insurance-service/v1/consumers/client-templates/{insuranceId}
     *
     * @param insuranceId Идентификатор договора страхования (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ClientTemplateList> getClientTemplates(Long insuranceId) throws RestClientException {
        return new ClientRestResult<>(getClientTemplatesInternal(insuranceId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ClientTemplateList>> getClientTemplatesInternal(Long insuranceId) throws RestClientException {
        if (insuranceId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "insuranceId", "getClientTemplates"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/consumers/client-templates/{insuranceId}")).variable("insuranceId", insuranceId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ClientTemplateList>(){});
    }

    /**
     * Получить список шаблонов заявлений и инструкций
     * PUT /insurance-service/v1/client-templates
     *
     * @param filter Тело запроса с данными фильтрации (optional)
     * @param hasFilter Признак фильтрации (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public RestPageImpl<ClientTemplateDataForList> getClientTemplatesList(Pageable pageable, FilterClientTemplates filter, Boolean hasFilter, long timeout) throws RestClientException {
        return getClientTemplatesList(pageable, filter, hasFilter).get(timeout);
    }

    /**
     * Получить список шаблонов заявлений и инструкций асинхронно
     * PUT /insurance-service/v1/client-templates
     *
     * @param filter Тело запроса с данными фильтрации (optional)
     * @param hasFilter Признак фильтрации (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<RestPageImpl<ClientTemplateDataForList>> getClientTemplatesList(Pageable pageable, FilterClientTemplates filter, Boolean hasFilter) throws RestClientException {
        return new ClientRestResult<>(getClientTemplatesListInternal(pageable, filter, hasFilter), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<RestPageImpl<ClientTemplateDataForList>>> getClientTemplatesListInternal(Pageable pageable, FilterClientTemplates filter, Boolean hasFilter) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/client-templates"));

        addPageableParams(uriBuilder, pageable);
        if (hasFilter != null)
            uriBuilder.param("hasFilter", hasFilter);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .body(filter);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<RestPageImpl<ClientTemplateDataForList>>(){});
    }

    /**
     * Получить масcив байтов файла, приложенного к записи справочника шаблонов и инструкций
     * GET /insurance-service/v1/attach/client-templates/{attachId}
     *
     * @param attachId Идентификатор файла (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return поток байтов файла
     * @throws RestClientException в случае неудачи
    */
    public byte[] getTemplateContent(String attachId, long timeout) throws RestClientException {
        return getTemplateContent(attachId).get(timeout);
    }

    /**
     * Получить масcив байтов файла, приложенного к записи справочника шаблонов и инструкций асинхронно
     * GET /insurance-service/v1/attach/client-templates/{attachId}
     *
     * @param attachId Идентификатор файла (required)
     * @return поток байтов файла
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<byte[]> getTemplateContent(String attachId) throws RestClientException {
        return new ClientRestResult<>(getTemplateContentInternal(attachId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<byte[]>> getTemplateContentInternal(String attachId) throws RestClientException {
        if (attachId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "attachId", "getTemplateContent"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/attach/client-templates/{attachId}")).variable("attachId", attachId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<byte[]>(){});
    }

    /**
     * Обновить запись справочника шаблонов заявлений и инструкций
     * PUT /insurance-service/v1/client-templates/{id}
     *
     * @param id Идентификатор записи справочника (required)
     * @param body Данные записи справочника шаблонов заявлений и инструкций (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientTemplateData updateClientTemplates(Long id, ClientTemplateData body, long timeout) throws RestClientException {
        return updateClientTemplates(id, body).get(timeout);
    }

    /**
     * Обновить запись справочника шаблонов заявлений и инструкций асинхронно
     * PUT /insurance-service/v1/client-templates/{id}
     *
     * @param id Идентификатор записи справочника (required)
     * @param body Данные записи справочника шаблонов заявлений и инструкций (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ClientTemplateData> updateClientTemplates(Long id, ClientTemplateData body) throws RestClientException {
        return new ClientRestResult<>(updateClientTemplatesInternal(id, body), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ClientTemplateData>> updateClientTemplatesInternal(Long id, ClientTemplateData body) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "updateClientTemplates"));
        if (body == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "body", "updateClientTemplates"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/client-templates/{id}")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .body(body);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ClientTemplateData>(){});
    }
    private String cutComments(String path) {
        return path.split("#", 2)[0];
    }

    private void addPageableParams(MicroServiceURIBuilder builder, Pageable pageable) {
        if (pageable != null) {
            builder.param("page", pageable.getPageNumber());
            builder.param("size", pageable.getPageSize());
            Sort sort = pageable.getSort();
            if (sort != null) {
                List<String> sortParams = new ArrayList<>();
                for (Sort.Order next : sort) {
                    sortParams.add(next.getProperty());
                }
                sortParams.add(sort.getOrderFor(sortParams.get(0)).getDirection().name());
                builder.param("sort", String.join(",", sortParams));
            }
        }
    }

    private void processStatusCodeErrors(Exception e) throws RestClientException {
            HttpStatus statusCode = RestUtils.getStatusCode(e);
            if (statusCode != null) {
                switch (statusCode) {
                    case INTERNAL_SERVER_ERROR:
                        throw new RestClientException(String.format(STATUS_CODE_TEMPLATE, HttpStatus.INTERNAL_SERVER_ERROR.toString()));
                    case CONFLICT:
                        throw new EntityExistsException();
                    case NOT_FOUND:
                        throw new NotFoundException();
                }
            }
            throw new RestClientException(e.toString());
    }
}
