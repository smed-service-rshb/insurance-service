/*
 * API микросервиса управления договорами страхования
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ru.softlab.efr.services.insurance;

import ru.softlab.efr.services.insurance.model.rest.CheckClientRq;
import ru.softlab.efr.services.insurance.model.rest.Client;
import ru.softlab.efr.services.insurance.model.rest.ClientInspectionResults;
import ru.softlab.efr.services.insurance.model.rest.DataChangeHistoryClient;
import ru.softlab.efr.services.insurance.model.rest.ErrorModel;
import ru.softlab.efr.services.insurance.model.rest.FindClientRq;
import ru.softlab.efr.services.insurance.model.rest.ListClientsResponse;
import java.time.LocalDate;
import org.springframework.core.io.Resource;
import ru.softlab.efr.services.insurance.model.rest.ShortClientData;

import ru.softlab.efr.infrastructure.transport.client.*;
import ru.softlab.efr.common.utilities.rest.*;
import ru.softlab.efr.common.utilities.rest.client.*;
import ru.softlab.efr.common.utilities.rest.converters.DateParser;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import ru.softlab.efr.infrastructure.transport.client.impl.JmsUriBuilder;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.util.*;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Содержит методы для взаимодействия с приложением insurance-service
 **/
@Component
public class ClientsDataClient {
    private static final String REQUIRED_PARAM_ERROR = "Не указан обязательный параметр '%s' при вызове %s";
    private String applicationName;
    private static final String STATUS_CODE_TEMPLATE = "status code: [%s]";

    private final MicroServiceTemplate microServiceTemplate;

    /**
     * Возвращяет экземпляр класса
     * @param microServiceTemplate - объект, реализующий интерфейс {@link MicroServiceTemplate}
     */
    public ClientsDataClient(MicroServiceTemplate microServiceTemplate) {
        this.microServiceTemplate = microServiceTemplate;
        this.applicationName = "insurance-service";
    }


    /**
     * Запустить процесс проверки всех клиентов по справочникам
     * GET /insurance-service/v2/clients/check/{updateId}
     *
     * @param dictName Справочник, по которому необходимо инициировать проверку (required)
     * @param updateId Идентификатор записи, которая содержит информацию о файле-справочнике (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void checkAllClients(String dictName, String updateId, long timeout) throws RestClientException {
        return checkAllClients(dictName, updateId).get(timeout);
    }

    /**
     * Запустить процесс проверки всех клиентов по справочникам асинхронно
     * GET /insurance-service/v2/clients/check/{updateId}
     *
     * @param dictName Справочник, по которому необходимо инициировать проверку (required)
     * @param updateId Идентификатор записи, которая содержит информацию о файле-справочнике (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> checkAllClients(String dictName, String updateId) throws RestClientException {
        return new ClientRestResult<>(checkAllClientsInternal(dictName, updateId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> checkAllClientsInternal(String dictName, String updateId) throws RestClientException {
        if (dictName == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "dictName", "checkAllClients"));
        if (updateId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "updateId", "checkAllClients"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/check/{updateId}")).variable("updateId", updateId);

        if (dictName != null)
            uriBuilder.param("dictName", dictName);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Список клиентов
     * GET /insurance-service/v2/clients/search
     *
     * @param surName Фамилия клиента (optional)
     * @param firstName Имя клиента (optional)
     * @param middleName Отчество клиента (optional)
     * @param birthDate Дата рождения (optional)
     * @param phoneNumber Номер телефона (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Результаты поиска
     * @throws RestClientException в случае неудачи
    */
    public ListClientsResponse clientsSearch(String surName, String firstName, String middleName, LocalDate birthDate, String phoneNumber, long timeout) throws RestClientException {
        return clientsSearch(surName, firstName, middleName, birthDate, phoneNumber).get(timeout);
    }

    /**
     * Список клиентов асинхронно
     * GET /insurance-service/v2/clients/search
     *
     * @param surName Фамилия клиента (optional)
     * @param firstName Имя клиента (optional)
     * @param middleName Отчество клиента (optional)
     * @param birthDate Дата рождения (optional)
     * @param phoneNumber Номер телефона (optional)
     * @return Результаты поиска
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ListClientsResponse> clientsSearch(String surName, String firstName, String middleName, LocalDate birthDate, String phoneNumber) throws RestClientException {
        return new ClientRestResult<>(clientsSearchInternal(surName, firstName, middleName, birthDate, phoneNumber), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ListClientsResponse>> clientsSearchInternal(String surName, String firstName, String middleName, LocalDate birthDate, String phoneNumber) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/search"));

        if (surName != null)
            uriBuilder.param("surName", surName);
        if (firstName != null)
            uriBuilder.param("firstName", firstName);
        if (middleName != null)
            uriBuilder.param("middleName", middleName);
        if (birthDate != null)
            uriBuilder.param("birthDate", DateParser.format(birthDate));
        if (phoneNumber != null)
            uriBuilder.param("phoneNumber", phoneNumber);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ListClientsResponse>(){});
    }

    /**
     * Поиск клиента при оформлении договора
     * POST /insurance-service/v2/clients/find
     *
     * @param findClientRq Запрос поиска клинта при оформлениии договора (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Данные по клиенту или пустое тело если клиент не найден
     * @throws RestClientException в случае неудачи
    */
    public Client findClient(FindClientRq findClientRq, long timeout) throws RestClientException {
        return findClient(findClientRq).get(timeout);
    }

    /**
     * Поиск клиента при оформлении договора асинхронно
     * POST /insurance-service/v2/clients/find
     *
     * @param findClientRq Запрос поиска клинта при оформлениии договора (required)
     * @return Данные по клиенту или пустое тело если клиент не найден
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Client> findClient(FindClientRq findClientRq) throws RestClientException {
        return new ClientRestResult<>(findClientInternal(findClientRq), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Client>> findClientInternal(FindClientRq findClientRq) throws RestClientException {
        if (findClientRq == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "findClientRq", "findClient"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/find"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(findClientRq);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Client>(){});
    }

    /**
     * Возвращает информацию о клиенте
     * GET /insurance-service/v2/clients/{clientId}
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Информацию о клиенте
     * @throws RestClientException в случае неудачи
    */
    public Client getClient(String clientId, long timeout) throws RestClientException {
        return getClient(clientId).get(timeout);
    }

    /**
     * Возвращает информацию о клиенте асинхронно
     * GET /insurance-service/v2/clients/{clientId}
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @return Информацию о клиенте
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Client> getClient(String clientId) throws RestClientException {
        return new ClientRestResult<>(getClientInternal(clientId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Client>> getClientInternal(String clientId) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "getClient"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/{clientId}")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Client>(){});
    }

    /**
     * Вернуть информацию об истории изменения данных пользователя
     * GET /insurance-service/v2/clients/{clientId}/historyChanges
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Информация об истории изменений
     * @throws RestClientException в случае неудачи
    */
    public DataChangeHistoryClient getClientHistoryChanges(Long clientId, long timeout) throws RestClientException {
        return getClientHistoryChanges(clientId).get(timeout);
    }

    /**
     * Вернуть информацию об истории изменения данных пользователя асинхронно
     * GET /insurance-service/v2/clients/{clientId}/historyChanges
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @return Информация об истории изменений
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<DataChangeHistoryClient> getClientHistoryChanges(Long clientId) throws RestClientException {
        return new ClientRestResult<>(getClientHistoryChangesInternal(clientId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<DataChangeHistoryClient>> getClientHistoryChangesInternal(Long clientId) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "getClientHistoryChanges"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/{clientId}/historyChanges")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<DataChangeHistoryClient>(){});
    }

    /**
     * Возвращает информацию о клиенте
     * GET /insurance-service/v2/consumer
     *
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Информацию о клиенте
     * @throws RestClientException в случае неудачи
    */
    public Client getConsumer(long timeout) throws RestClientException {
        return getConsumer().get(timeout);
    }

    /**
     * Возвращает информацию о клиенте асинхронно
     * GET /insurance-service/v2/consumer
     *
     * @return Информацию о клиенте
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Client> getConsumer() throws RestClientException {
        return new ClientRestResult<>(getConsumerInternal(), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Client>> getConsumerInternal() throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/consumer"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Client>(){});
    }

    /**
     * Возвращает информацию о последних проверках клиента
     * GET /insurance-service/v2/clients/{clientId}/inspectionResults
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Информацию о клиенте
     * @throws RestClientException в случае неудачи
    */
    public ClientInspectionResults getInspectionResults(String clientId, long timeout) throws RestClientException {
        return getInspectionResults(clientId).get(timeout);
    }

    /**
     * Возвращает информацию о последних проверках клиента асинхронно
     * GET /insurance-service/v2/clients/{clientId}/inspectionResults
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @return Информацию о клиенте
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ClientInspectionResults> getInspectionResults(String clientId) throws RestClientException {
        return new ClientRestResult<>(getInspectionResultsInternal(clientId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ClientInspectionResults>> getInspectionResultsInternal(String clientId) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "getInspectionResults"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/{clientId}/inspectionResults")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ClientInspectionResults>(){});
    }

    /**
     * Список клиентов
     * GET /insurance-service/v2/clients
     *
     * @param surName Фамилия клиента (optional)
     * @param firstName Имя клиента (optional)
     * @param middleName Отчество клиента (optional)
     * @param birthDate Дата рождения (optional)
     * @param docType Тип документа (optional)
     * @param docSeries Серия документа (optional)
     * @param docNumber Номер документа (optional)
     * @param phoneNumber Номер телефона (optional)
     * @param email email (optional)
     * @param startConclusionDate Начальная дата периода оформления договора (optional)
     * @param endConclusionDate Конечная дата периода оформления договора (optional)
     * @param startCheckDate Начальная дата периода выполнения проверки (optional)
     * @param endCheckDate Конечная дата периода выполнения проверки (optional)
     * @param type Вид проверки (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Результаты поиска
     * @throws RestClientException в случае неудачи
    */
    public ListClientsResponse listClients(String surName, String firstName, String middleName, LocalDate birthDate, String docType, String docSeries, String docNumber, String phoneNumber, String email, LocalDate startConclusionDate, LocalDate endConclusionDate, LocalDate startCheckDate, LocalDate endCheckDate, String type, long timeout) throws RestClientException {
        return listClients(surName, firstName, middleName, birthDate, docType, docSeries, docNumber, phoneNumber, email, startConclusionDate, endConclusionDate, startCheckDate, endCheckDate, type).get(timeout);
    }

    /**
     * Список клиентов асинхронно
     * GET /insurance-service/v2/clients
     *
     * @param surName Фамилия клиента (optional)
     * @param firstName Имя клиента (optional)
     * @param middleName Отчество клиента (optional)
     * @param birthDate Дата рождения (optional)
     * @param docType Тип документа (optional)
     * @param docSeries Серия документа (optional)
     * @param docNumber Номер документа (optional)
     * @param phoneNumber Номер телефона (optional)
     * @param email email (optional)
     * @param startConclusionDate Начальная дата периода оформления договора (optional)
     * @param endConclusionDate Конечная дата периода оформления договора (optional)
     * @param startCheckDate Начальная дата периода выполнения проверки (optional)
     * @param endCheckDate Конечная дата периода выполнения проверки (optional)
     * @param type Вид проверки (optional)
     * @return Результаты поиска
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<ListClientsResponse> listClients(String surName, String firstName, String middleName, LocalDate birthDate, String docType, String docSeries, String docNumber, String phoneNumber, String email, LocalDate startConclusionDate, LocalDate endConclusionDate, LocalDate startCheckDate, LocalDate endCheckDate, String type) throws RestClientException {
        return new ClientRestResult<>(listClientsInternal(surName, firstName, middleName, birthDate, docType, docSeries, docNumber, phoneNumber, email, startConclusionDate, endConclusionDate, startCheckDate, endCheckDate, type), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<ListClientsResponse>> listClientsInternal(String surName, String firstName, String middleName, LocalDate birthDate, String docType, String docSeries, String docNumber, String phoneNumber, String email, LocalDate startConclusionDate, LocalDate endConclusionDate, LocalDate startCheckDate, LocalDate endCheckDate, String type) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients"));

        if (surName != null)
            uriBuilder.param("surName", surName);
        if (firstName != null)
            uriBuilder.param("firstName", firstName);
        if (middleName != null)
            uriBuilder.param("middleName", middleName);
        if (birthDate != null)
            uriBuilder.param("birthDate", DateParser.format(birthDate));
        if (docType != null)
            uriBuilder.param("docType", docType);
        if (docSeries != null)
            uriBuilder.param("docSeries", docSeries);
        if (docNumber != null)
            uriBuilder.param("docNumber", docNumber);
        if (phoneNumber != null)
            uriBuilder.param("phoneNumber", phoneNumber);
        if (email != null)
            uriBuilder.param("email", email);
        if (startConclusionDate != null)
            uriBuilder.param("startConclusionDate", DateParser.format(startConclusionDate));
        if (endConclusionDate != null)
            uriBuilder.param("endConclusionDate", DateParser.format(endConclusionDate));
        if (startCheckDate != null)
            uriBuilder.param("startCheckDate", DateParser.format(startCheckDate));
        if (endCheckDate != null)
            uriBuilder.param("endCheckDate", DateParser.format(endCheckDate));
        if (type != null)
            uriBuilder.param("type", type);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<ListClientsResponse>(){});
    }

    /**
     * Запуск ручной проверки клиентов
     * POST /insurance-service/v2/clients/check
     *
     * @param checkClientData Данные для проверки клиентов (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void manualCheckClient(CheckClientRq checkClientData, long timeout) throws RestClientException {
        return manualCheckClient(checkClientData).get(timeout);
    }

    /**
     * Запуск ручной проверки клиентов асинхронно
     * POST /insurance-service/v2/clients/check
     *
     * @param checkClientData Данные для проверки клиентов (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> manualCheckClient(CheckClientRq checkClientData) throws RestClientException {
        return new ClientRestResult<>(manualCheckClientInternal(checkClientData), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> manualCheckClientInternal(CheckClientRq checkClientData) throws RestClientException {
        if (checkClientData == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "checkClientData", "manualCheckClient"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/check"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(checkClientData);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Обновить информацию о клиенте
     * PUT /insurance-service/v2/clients/{clientId}
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param updateClientInfo Данные обновления информации о клиенте. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void putClient(Long clientId, Client updateClientInfo, long timeout) throws RestClientException {
        return putClient(clientId, updateClientInfo).get(timeout);
    }

    /**
     * Обновить информацию о клиенте асинхронно
     * PUT /insurance-service/v2/clients/{clientId}
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param updateClientInfo Данные обновления информации о клиенте. (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> putClient(Long clientId, Client updateClientInfo) throws RestClientException {
        return new ClientRestResult<>(putClientInternal(clientId, updateClientInfo), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> putClientInternal(Long clientId, Client updateClientInfo) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "putClient"));
        if (updateClientInfo == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "updateClientInfo", "putClient"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/{clientId}")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .body(updateClientInfo);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Сохраняет только обязательные поля данных клиента
     * POST /insurance-service/v2/clients/saveShortClientData
     *
     * @param shortClientData Данные клиента которые необходимо сохранить (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Идентификатор клиента
     * @throws RestClientException в случае неудачи
    */
    public Long saveClientDataWithRequiredFields(ShortClientData shortClientData, long timeout) throws RestClientException {
        return saveClientDataWithRequiredFields(shortClientData).get(timeout);
    }

    /**
     * Сохраняет только обязательные поля данных клиента асинхронно
     * POST /insurance-service/v2/clients/saveShortClientData
     *
     * @param shortClientData Данные клиента которые необходимо сохранить (required)
     * @return Идентификатор клиента
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Long> saveClientDataWithRequiredFields(ShortClientData shortClientData) throws RestClientException {
        return new ClientRestResult<>(saveClientDataWithRequiredFieldsInternal(shortClientData), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Long>> saveClientDataWithRequiredFieldsInternal(ShortClientData shortClientData) throws RestClientException {
        if (shortClientData == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "shortClientData", "saveClientDataWithRequiredFields"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/saveShortClientData"));

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(shortClientData);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Long>(){});
    }

    /**
     * Получить word файл с выгрузкой одного клиента
     * GET /insurance-service/v2/clients/{clientId}/unload/word
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public Resource unloadClientWord(Integer clientId, long timeout) throws RestClientException {
        return unloadClientWord(clientId).get(timeout);
    }

    /**
     * Получить word файл с выгрузкой одного клиента асинхронно
     * GET /insurance-service/v2/clients/{clientId}/unload/word
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Resource> unloadClientWord(Integer clientId) throws RestClientException {
        return new ClientRestResult<>(unloadClientWordInternal(clientId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Resource>> unloadClientWordInternal(Integer clientId) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "unloadClientWord"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/{clientId}/unload/word")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Resource>(){});
    }

    /**
     * Получить xml файл с выгрузкой одного клиента
     * GET /insurance-service/v2/clients/{clientId}/unload/xml
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public byte[] unloadClientXml(String clientId, long timeout) throws RestClientException {
        return unloadClientXml(clientId).get(timeout);
    }

    /**
     * Получить xml файл с выгрузкой одного клиента асинхронно
     * GET /insurance-service/v2/clients/{clientId}/unload/xml
     *
     * @param clientId Идентификатор клиента в системе (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<byte[]> unloadClientXml(String clientId) throws RestClientException {
        return new ClientRestResult<>(unloadClientXmlInternal(clientId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<byte[]>> unloadClientXmlInternal(String clientId) throws RestClientException {
        if (clientId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "clientId", "unloadClientXml"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/{clientId}/unload/xml")).variable("clientId", clientId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<byte[]>(){});
    }

    /**
     * Получить xml файл с выгрузкой списка клиентов, удовлетворяющих определённым условиям
     * GET /insurance-service/v2/clients/unload/xml
     *
     * @param contractIds Список идентификаторов договоров, для которых необходимо выгрузить клиентов (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public byte[] unloadClientsXmlByCriteria(List<Long> contractIds, long timeout) throws RestClientException {
        return unloadClientsXmlByCriteria(contractIds).get(timeout);
    }

    /**
     * Получить xml файл с выгрузкой списка клиентов, удовлетворяющих определённым условиям асинхронно
     * GET /insurance-service/v2/clients/unload/xml
     *
     * @param contractIds Список идентификаторов договоров, для которых необходимо выгрузить клиентов (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<byte[]> unloadClientsXmlByCriteria(List<Long> contractIds) throws RestClientException {
        return new ClientRestResult<>(unloadClientsXmlByCriteriaInternal(contractIds), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<byte[]>> unloadClientsXmlByCriteriaInternal(List<Long> contractIds) throws RestClientException {
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/clients/unload/xml"));

        if (contractIds != null && !contractIds.isEmpty())
            contractIds.forEach(p -> uriBuilder.param("contractIds", p));
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<byte[]>(){});
    }

    /**
     * Обновить признак согласия у клиента
     * PUT /insurance-service/v1/client/{id}/workflow-agreements
     *
     * @param id Идентификатор записи справочника (required)
     * @param workflowAgreements комментарий к заявлению (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void updateClientWorkflow(Long id, Boolean workflowAgreements, long timeout) throws RestClientException {
        return updateClientWorkflow(id, workflowAgreements).get(timeout);
    }

    /**
     * Обновить признак согласия у клиента асинхронно
     * PUT /insurance-service/v1/client/{id}/workflow-agreements
     *
     * @param id Идентификатор записи справочника (required)
     * @param workflowAgreements комментарий к заявлению (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> updateClientWorkflow(Long id, Boolean workflowAgreements) throws RestClientException {
        return new ClientRestResult<>(updateClientWorkflowInternal(id, workflowAgreements), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> updateClientWorkflowInternal(Long id, Boolean workflowAgreements) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "updateClientWorkflow"));
        if (workflowAgreements == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "workflowAgreements", "updateClientWorkflow"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v1/client/{id}/workflow-agreements")).variable("id", id);

        if (workflowAgreements != null)
            uriBuilder.param("workflowAgreements", workflowAgreements);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.PUT, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }
    private String cutComments(String path) {
        return path.split("#", 2)[0];
    }

    private void addPageableParams(MicroServiceURIBuilder builder, Pageable pageable) {
        if (pageable != null) {
            builder.param("page", pageable.getPageNumber());
            builder.param("size", pageable.getPageSize());
            Sort sort = pageable.getSort();
            if (sort != null) {
                List<String> sortParams = new ArrayList<>();
                for (Sort.Order next : sort) {
                    sortParams.add(next.getProperty());
                }
                sortParams.add(sort.getOrderFor(sortParams.get(0)).getDirection().name());
                builder.param("sort", String.join(",", sortParams));
            }
        }
    }

    private void processStatusCodeErrors(Exception e) throws RestClientException {
            HttpStatus statusCode = RestUtils.getStatusCode(e);
            if (statusCode != null) {
                switch (statusCode) {
                    case INTERNAL_SERVER_ERROR:
                        throw new RestClientException(String.format(STATUS_CODE_TEMPLATE, HttpStatus.INTERNAL_SERVER_ERROR.toString()));
                    case CONFLICT:
                        throw new EntityExistsException();
                    case NOT_FOUND:
                        throw new NotFoundException();
                }
            }
            throw new RestClientException(e.toString());
    }
}
