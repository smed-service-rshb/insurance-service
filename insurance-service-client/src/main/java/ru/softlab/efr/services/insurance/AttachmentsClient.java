/*
 * API микросервиса управления договорами страхования
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

package ru.softlab.efr.services.insurance;

import ru.softlab.efr.services.insurance.model.rest.AttachedDocRs;
import ru.softlab.efr.services.insurance.model.rest.AttachedList;
import ru.softlab.efr.services.insurance.model.rest.AttachedRequestAttachData;
import ru.softlab.efr.services.insurance.model.rest.Attachment;
import ru.softlab.efr.services.insurance.model.rest.AttachmentData;
import ru.softlab.efr.services.insurance.model.rest.ErrorModel;
import org.springframework.core.io.Resource;
import ru.softlab.efr.services.insurance.model.rest.Statement;
import ru.softlab.efr.services.insurance.model.rest.StatementsData;
import ru.softlab.efr.services.insurance.model.rest.UuidRs;

import ru.softlab.efr.infrastructure.transport.client.*;
import ru.softlab.efr.common.utilities.rest.*;
import ru.softlab.efr.common.utilities.rest.client.*;
import ru.softlab.efr.common.utilities.rest.converters.DateParser;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import ru.softlab.efr.infrastructure.transport.client.impl.JmsUriBuilder;

import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.*;
import org.springframework.util.*;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.stereotype.Component;

import java.util.*;

/**
 * Содержит методы для взаимодействия с приложением insurance-service
 **/
@Component
public class AttachmentsClient {
    private static final String REQUIRED_PARAM_ERROR = "Не указан обязательный параметр '%s' при вызове %s";
    private String applicationName;
    private static final String STATUS_CODE_TEMPLATE = "status code: [%s]";

    private final MicroServiceTemplate microServiceTemplate;

    /**
     * Возвращяет экземпляр класса
     * @param microServiceTemplate - объект, реализующий интерфейс {@link MicroServiceTemplate}
     */
    public AttachmentsClient(MicroServiceTemplate microServiceTemplate) {
        this.microServiceTemplate = microServiceTemplate;
        this.applicationName = "insurance-service";
    }


    /**
     * Добавить комментарий к заявлению
     * POST /insurance-service/v2/contract/attachments/statements/{statementId}/comment
     *
     * @param statementId Id заявления. (required)
     * @param comment комментарий к заявлению (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void changeStatementComment(Long statementId, String comment, long timeout) throws RestClientException {
        return changeStatementComment(statementId, comment).get(timeout);
    }

    /**
     * Добавить комментарий к заявлению асинхронно
     * POST /insurance-service/v2/contract/attachments/statements/{statementId}/comment
     *
     * @param statementId Id заявления. (required)
     * @param comment комментарий к заявлению (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> changeStatementComment(Long statementId, String comment) throws RestClientException {
        return new ClientRestResult<>(changeStatementCommentInternal(statementId, comment), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> changeStatementCommentInternal(Long statementId, String comment) throws RestClientException {
        if (statementId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "statementId", "changeStatementComment"));
        if (comment == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "comment", "changeStatementComment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/attachments/statements/{statementId}/comment")).variable("statementId", statementId);

        if (comment != null)
            uriBuilder.param("comment", comment);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Создать форму заявления.
     * POST /insurance-service/v2/contract/{insuranceId}/attachments/statements/{statementType}
     *
     * @param insuranceId Идентификатор экземпляра договора страхования (required)
     * @param statementType Статус заявления:   NEED_WITHDRAW_APPLICATION - Требуется заявление о выплате,   WITHDRAW_APPLICATION_RECEIVED - Получено заявление о выплате,   CHANGING_APPLICATION_RECEIVED - Получено заявление на изменение договора,   REFUSING_APPLICATION_RECEIVED - Получено заявление об отказе,   CANCELLATION_APPLICATION_RECEIVED - Получено заявление о расторжении договора  (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Форма созданного заявления.
     * @throws RestClientException в случае неудачи
    */
    public Statement createStatement(Long insuranceId, String statementType, long timeout) throws RestClientException {
        return createStatement(insuranceId, statementType).get(timeout);
    }

    /**
     * Создать форму заявления. асинхронно
     * POST /insurance-service/v2/contract/{insuranceId}/attachments/statements/{statementType}
     *
     * @param insuranceId Идентификатор экземпляра договора страхования (required)
     * @param statementType Статус заявления:   NEED_WITHDRAW_APPLICATION - Требуется заявление о выплате,   WITHDRAW_APPLICATION_RECEIVED - Получено заявление о выплате,   CHANGING_APPLICATION_RECEIVED - Получено заявление на изменение договора,   REFUSING_APPLICATION_RECEIVED - Получено заявление об отказе,   CANCELLATION_APPLICATION_RECEIVED - Получено заявление о расторжении договора  (required)
     * @return Форма созданного заявления.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Statement> createStatement(Long insuranceId, String statementType) throws RestClientException {
        return new ClientRestResult<>(createStatementInternal(insuranceId, statementType), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Statement>> createStatementInternal(Long insuranceId, String statementType) throws RestClientException {
        if (insuranceId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "insuranceId", "createStatement"));
        if (statementType == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "statementType", "createStatement"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/{insuranceId}/attachments/statements/{statementType}")).variable("insuranceId", insuranceId).variable("statementType", statementType);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Statement>(){});
    }

    /**
     * Удалить файл.
     * DELETE /insurance-service/v2/contract/attachment/{attachId}
     *
     * @param attachId Идентификатор файла, прикреплённого к договору страхования. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void deleteAttachment(String attachId, long timeout) throws RestClientException {
        return deleteAttachment(attachId).get(timeout);
    }

    /**
     * Удалить файл. асинхронно
     * DELETE /insurance-service/v2/contract/attachment/{attachId}
     *
     * @param attachId Идентификатор файла, прикреплённого к договору страхования. (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> deleteAttachment(String attachId) throws RestClientException {
        return new ClientRestResult<>(deleteAttachmentInternal(attachId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> deleteAttachmentInternal(String attachId) throws RestClientException {
        if (attachId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "attachId", "deleteAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/attachment/{attachId}")).variable("attachId", attachId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.DELETE, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Удалить файл, прикреплённый к обращению клиента
     * DELETE /insurance-service/v2/client-request/{requestAttachId}/attachment
     *
     * @param requestAttachId Идентификатор файла, прикреплённого к обращению клиента (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void deleteRequestAttachment(Long requestAttachId, long timeout) throws RestClientException {
        return deleteRequestAttachment(requestAttachId).get(timeout);
    }

    /**
     * Удалить файл, прикреплённый к обращению клиента асинхронно
     * DELETE /insurance-service/v2/client-request/{requestAttachId}/attachment
     *
     * @param requestAttachId Идентификатор файла, прикреплённого к обращению клиента (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> deleteRequestAttachment(Long requestAttachId) throws RestClientException {
        return new ClientRestResult<>(deleteRequestAttachmentInternal(requestAttachId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> deleteRequestAttachmentInternal(Long requestAttachId) throws RestClientException {
        if (requestAttachId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "requestAttachId", "deleteRequestAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/client-request/{requestAttachId}/attachment")).variable("requestAttachId", requestAttachId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.DELETE, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Получить контент документа
     * GET /insurance-service/v2/contract/attachment/{attachId}
     *
     * @param attachId Идентификатор файла, прикреплённого к договору страхования. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Контент файла
     * @throws RestClientException в случае неудачи
    */
    public byte[] getAttachmentContent(String attachId, long timeout) throws RestClientException {
        return getAttachmentContent(attachId).get(timeout);
    }

    /**
     * Получить контент документа асинхронно
     * GET /insurance-service/v2/contract/attachment/{attachId}
     *
     * @param attachId Идентификатор файла, прикреплённого к договору страхования. (required)
     * @return Контент файла
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<byte[]> getAttachmentContent(String attachId) throws RestClientException {
        return new ClientRestResult<>(getAttachmentContentInternal(attachId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<byte[]>> getAttachmentContentInternal(String attachId) throws RestClientException {
        if (attachId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "attachId", "getAttachmentContent"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/attachment/{attachId}")).variable("attachId", attachId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<byte[]>(){});
    }

    /**
     * Получить список с информацией по всем прикрепленным документам
     * GET /insurance-service/v2/contract/{id}/attachment
     *
     * @param id Идентификатор экземпляра договора страхования. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Список прикреплённых документов к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public AttachedDocRs getAttachmentList(Long id, long timeout) throws RestClientException {
        return getAttachmentList(id).get(timeout);
    }

    /**
     * Получить список с информацией по всем прикрепленным документам асинхронно
     * GET /insurance-service/v2/contract/{id}/attachment
     *
     * @param id Идентификатор экземпляра договора страхования. (required)
     * @return Список прикреплённых документов к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AttachedDocRs> getAttachmentList(Long id) throws RestClientException {
        return new ClientRestResult<>(getAttachmentListInternal(id), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AttachedDocRs>> getAttachmentListInternal(Long id) throws RestClientException {
        if (id == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "id", "getAttachmentList"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/{id}/attachment")).variable("id", id);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AttachedDocRs>(){});
    }

    /**
     * Получить форму самосертификации для проверки на существование
     * GET /insurance-service/v2/contract/{contractId}/attachments/certification
     *
     * @param contractId Идентификатор экземпляра договора страхования. (required)
     * @param type Id блока страхователя или застрахованного (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Прикрепленная Форма самосертификации к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public Attachment getCheckExistenceAttachment(Long contractId, String type, long timeout) throws RestClientException {
        return getCheckExistenceAttachment(contractId, type).get(timeout);
    }

    /**
     * Получить форму самосертификации для проверки на существование асинхронно
     * GET /insurance-service/v2/contract/{contractId}/attachments/certification
     *
     * @param contractId Идентификатор экземпляра договора страхования. (required)
     * @param type Id блока страхователя или застрахованного (required)
     * @return Прикрепленная Форма самосертификации к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Attachment> getCheckExistenceAttachment(Long contractId, String type) throws RestClientException {
        return new ClientRestResult<>(getCheckExistenceAttachmentInternal(contractId, type), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Attachment>> getCheckExistenceAttachmentInternal(Long contractId, String type) throws RestClientException {
        if (contractId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "contractId", "getCheckExistenceAttachment"));
        if (type == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "type", "getCheckExistenceAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/{contractId}/attachments/certification")).variable("contractId", contractId);

        if (type != null)
            uriBuilder.param("type", type);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Attachment>(){});
    }

    /**
     * Получить форму самосертификации для проверки на существование
     * GET /insurance-service/v2/contract/temp/{uuid}/attachments/certification
     *
     * @param uuid uuid экземпляра договора страхования. (required)
     * @param type Id блока страхователя или застрахованного (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Прикрепленная Форма самосертификации к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public Attachment getCheckExistenceTempAttachment(String uuid, String type, long timeout) throws RestClientException {
        return getCheckExistenceTempAttachment(uuid, type).get(timeout);
    }

    /**
     * Получить форму самосертификации для проверки на существование асинхронно
     * GET /insurance-service/v2/contract/temp/{uuid}/attachments/certification
     *
     * @param uuid uuid экземпляра договора страхования. (required)
     * @param type Id блока страхователя или застрахованного (required)
     * @return Прикрепленная Форма самосертификации к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Attachment> getCheckExistenceTempAttachment(String uuid, String type) throws RestClientException {
        return new ClientRestResult<>(getCheckExistenceTempAttachmentInternal(uuid, type), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Attachment>> getCheckExistenceTempAttachmentInternal(String uuid, String type) throws RestClientException {
        if (uuid == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "uuid", "getCheckExistenceTempAttachment"));
        if (type == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "type", "getCheckExistenceTempAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/temp/{uuid}/attachments/certification")).variable("uuid", uuid);

        if (type != null)
            uriBuilder.param("type", type);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Attachment>(){});
    }

    /**
     * Получить содержимое файла, прикреплённого к обращению клиента
     * GET /insurance-service/v2/client-request/{requestAttachId}/attachment
     *
     * @param requestAttachId Идентификатор файла, прикреплённого к обращению клиента (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Контент файла
     * @throws RestClientException в случае неудачи
    */
    public byte[] getRequestAttachmentContent(Long requestAttachId, long timeout) throws RestClientException {
        return getRequestAttachmentContent(requestAttachId).get(timeout);
    }

    /**
     * Получить содержимое файла, прикреплённого к обращению клиента асинхронно
     * GET /insurance-service/v2/client-request/{requestAttachId}/attachment
     *
     * @param requestAttachId Идентификатор файла, прикреплённого к обращению клиента (required)
     * @return Контент файла
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<byte[]> getRequestAttachmentContent(Long requestAttachId) throws RestClientException {
        return new ClientRestResult<>(getRequestAttachmentContentInternal(requestAttachId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<byte[]>> getRequestAttachmentContentInternal(Long requestAttachId) throws RestClientException {
        if (requestAttachId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "requestAttachId", "getRequestAttachmentContent"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/client-request/{requestAttachId}/attachment")).variable("requestAttachId", requestAttachId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<byte[]>(){});
    }

    /**
     * Получить список с информацией по всем документам, прикреплённым к обращению клиента.
     * GET /insurance-service/v2/client-request/temp/{requestId}/attachment
     *
     * @param requestId Идентификатор обращения клиента (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AttachedList getRequestAttachmentList(Long requestId, long timeout) throws RestClientException {
        return getRequestAttachmentList(requestId).get(timeout);
    }

    /**
     * Получить список с информацией по всем документам, прикреплённым к обращению клиента. асинхронно
     * GET /insurance-service/v2/client-request/temp/{requestId}/attachment
     *
     * @param requestId Идентификатор обращения клиента (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AttachedList> getRequestAttachmentList(Long requestId) throws RestClientException {
        return new ClientRestResult<>(getRequestAttachmentListInternal(requestId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AttachedList>> getRequestAttachmentListInternal(Long requestId) throws RestClientException {
        if (requestId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "requestId", "getRequestAttachmentList"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/client-request/temp/{requestId}/attachment")).variable("requestId", requestId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AttachedList>(){});
    }

    /**
     * Получить список заявлений с информацией по всем прикрепленным документам
     * GET /insurance-service/v2/contract/{insuranceId}/attachments/statements
     *
     * @param insuranceId ID экземпляра договора страхования. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Список прикреплённых документов (заявлений) к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public StatementsData getStatementAttachmentList(Long insuranceId, long timeout) throws RestClientException {
        return getStatementAttachmentList(insuranceId).get(timeout);
    }

    /**
     * Получить список заявлений с информацией по всем прикрепленным документам асинхронно
     * GET /insurance-service/v2/contract/{insuranceId}/attachments/statements
     *
     * @param insuranceId ID экземпляра договора страхования. (required)
     * @return Список прикреплённых документов (заявлений) к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<StatementsData> getStatementAttachmentList(Long insuranceId) throws RestClientException {
        return new ClientRestResult<>(getStatementAttachmentListInternal(insuranceId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<StatementsData>> getStatementAttachmentListInternal(Long insuranceId) throws RestClientException {
        if (insuranceId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "insuranceId", "getStatementAttachmentList"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/{insuranceId}/attachments/statements")).variable("insuranceId", insuranceId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<StatementsData>(){});
    }

    /**
     * Получить заявление по id
     * GET /insurance-service/v2/contract/attachments/statements/{statementId}
     *
     * @param statementId ID заявления (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Получить заявление с прикрепленным документами.
     * @throws RestClientException в случае неудачи
    */
    public Statement getStatementById(Long statementId, long timeout) throws RestClientException {
        return getStatementById(statementId).get(timeout);
    }

    /**
     * Получить заявление по id асинхронно
     * GET /insurance-service/v2/contract/attachments/statements/{statementId}
     *
     * @param statementId ID заявления (required)
     * @return Получить заявление с прикрепленным документами.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Statement> getStatementById(Long statementId) throws RestClientException {
        return new ClientRestResult<>(getStatementByIdInternal(statementId), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Statement>> getStatementByIdInternal(Long statementId) throws RestClientException {
        if (statementId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "statementId", "getStatementById"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/attachments/statements/{statementId}")).variable("statementId", statementId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Statement>(){});
    }

    /**
     * Получить список с информацией по всем прикрепленным документам
     * GET /insurance-service/v2/contract/temp/{uuid}/attachment
     *
     * @param uuid UUID экземпляра договора страхования. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return Список прикреплённых документов к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public AttachedDocRs getTempAttachmentList(String uuid, long timeout) throws RestClientException {
        return getTempAttachmentList(uuid).get(timeout);
    }

    /**
     * Получить список с информацией по всем прикрепленным документам асинхронно
     * GET /insurance-service/v2/contract/temp/{uuid}/attachment
     *
     * @param uuid UUID экземпляра договора страхования. (required)
     * @return Список прикреплённых документов к данному договору страхования.
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AttachedDocRs> getTempAttachmentList(String uuid) throws RestClientException {
        return new ClientRestResult<>(getTempAttachmentListInternal(uuid), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AttachedDocRs>> getTempAttachmentListInternal(String uuid) throws RestClientException {
        if (uuid == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "uuid", "getTempAttachmentList"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/temp/{uuid}/attachment")).variable("uuid", uuid);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.GET, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AttachedDocRs>(){});
    }

    /**
     * Добавить признак полного пакета документов для заявления
     * POST /insurance-service/v2/contract/attachments/statements/{statementId}/status
     *
     * @param statementId Id заявления. (required)
     * @param statementCompleteStatus Статус заявления:   FULL - Полный набор документов   NOT_FULL - Не полный набор документов   NEUTRAL - Не проверено  (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void setStatementDocumentStatus(Long statementId, String statementCompleteStatus, long timeout) throws RestClientException {
        return setStatementDocumentStatus(statementId, statementCompleteStatus).get(timeout);
    }

    /**
     * Добавить признак полного пакета документов для заявления асинхронно
     * POST /insurance-service/v2/contract/attachments/statements/{statementId}/status
     *
     * @param statementId Id заявления. (required)
     * @param statementCompleteStatus Статус заявления:   FULL - Полный набор документов   NOT_FULL - Не полный набор документов   NEUTRAL - Не проверено  (required)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> setStatementDocumentStatus(Long statementId, String statementCompleteStatus) throws RestClientException {
        return new ClientRestResult<>(setStatementDocumentStatusInternal(statementId, statementCompleteStatus), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> setStatementDocumentStatusInternal(Long statementId, String statementCompleteStatus) throws RestClientException {
        if (statementId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "statementId", "setStatementDocumentStatus"));
        if (statementCompleteStatus == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "statementCompleteStatus", "setStatementDocumentStatus"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/attachments/statements/{statementId}/status")).variable("statementId", statementId);

        if (statementCompleteStatus != null)
            uriBuilder.param("statementCompleteStatus", statementCompleteStatus);
        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .build();
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Загрузить файл, прикреплённый к договору страхования.
     * POST /insurance-service/v2/contract/{contractId}/attachment/{documentType}
     *
     * @param contractId Идентификатор экземпляра договора страхования (required)
     * @param documentType Идентификатор из справочника обязательных документов (required)
     * @param content Контент (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public String uploadAttachment(Long contractId, Long documentType, Resource content, long timeout) throws RestClientException {
        return uploadAttachment(contractId, documentType, content).get(timeout);
    }

    /**
     * Загрузить файл, прикреплённый к договору страхования. асинхронно
     * POST /insurance-service/v2/contract/{contractId}/attachment/{documentType}
     *
     * @param contractId Идентификатор экземпляра договора страхования (required)
     * @param documentType Идентификатор из справочника обязательных документов (required)
     * @param content Контент (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<String> uploadAttachment(Long contractId, Long documentType, Resource content) throws RestClientException {
        return new ClientRestResult<>(uploadAttachmentInternal(contractId, documentType, content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<String>> uploadAttachmentInternal(Long contractId, Long documentType, Resource content) throws RestClientException {
        if (contractId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "contractId", "uploadAttachment"));
        if (documentType == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "documentType", "uploadAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/{contractId}/attachment/{documentType}")).variable("contractId", contractId).variable("documentType", documentType);

        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<String>(){});
    }

    /**
     * Загрузить заполненную форму самосертификации, для иностранного налогового резидента.
     * POST /insurance-service/v2/contract/{contractId}/attachment/certification
     *
     * @param contractId Идентификатор экземпляра договора страхования (required)
     * @param blockId Id блока страхователя или застрахованного (required)
     * @param content Контент (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public String uploadForeignResidentAttachment(Long contractId, String blockId, Resource content, long timeout) throws RestClientException {
        return uploadForeignResidentAttachment(contractId, blockId, content).get(timeout);
    }

    /**
     * Загрузить заполненную форму самосертификации, для иностранного налогового резидента. асинхронно
     * POST /insurance-service/v2/contract/{contractId}/attachment/certification
     *
     * @param contractId Идентификатор экземпляра договора страхования (required)
     * @param blockId Id блока страхователя или застрахованного (required)
     * @param content Контент (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<String> uploadForeignResidentAttachment(Long contractId, String blockId, Resource content) throws RestClientException {
        return new ClientRestResult<>(uploadForeignResidentAttachmentInternal(contractId, blockId, content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<String>> uploadForeignResidentAttachmentInternal(Long contractId, String blockId, Resource content) throws RestClientException {
        if (contractId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "contractId", "uploadForeignResidentAttachment"));
        if (blockId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "blockId", "uploadForeignResidentAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/{contractId}/attachment/certification")).variable("contractId", contractId);

        if (blockId != null)
            uriBuilder.param("blockId", blockId);
        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<String>(){});
    }

    /**
     * Загрузить заполненную форму самосертификации, для иностранного налогового резидента.
     * POST /insurance-service/v2/contract/temp/{uuid}/attachment/certification
     *
     * @param uuid uuid экземпляра договора страхования (required)
     * @param blockId Id блока страхователя или застрахованного (required)
     * @param content Контент (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public UuidRs uploadForeignResidentTempAttachment(String uuid, String blockId, Resource content, long timeout) throws RestClientException {
        return uploadForeignResidentTempAttachment(uuid, blockId, content).get(timeout);
    }

    /**
     * Загрузить заполненную форму самосертификации, для иностранного налогового резидента. асинхронно
     * POST /insurance-service/v2/contract/temp/{uuid}/attachment/certification
     *
     * @param uuid uuid экземпляра договора страхования (required)
     * @param blockId Id блока страхователя или застрахованного (required)
     * @param content Контент (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<UuidRs> uploadForeignResidentTempAttachment(String uuid, String blockId, Resource content) throws RestClientException {
        return new ClientRestResult<>(uploadForeignResidentTempAttachmentInternal(uuid, blockId, content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<UuidRs>> uploadForeignResidentTempAttachmentInternal(String uuid, String blockId, Resource content) throws RestClientException {
        if (uuid == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "uuid", "uploadForeignResidentTempAttachment"));
        if (blockId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "blockId", "uploadForeignResidentTempAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/temp/{uuid}/attachment/certification")).variable("uuid", uuid);

        if (blockId != null)
            uriBuilder.param("blockId", blockId);
        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<UuidRs>(){});
    }

    /**
     * Прикрепить файл к обращению.
     * POST /insurance-service/v2/client-request/temp/{requestId}/attachment
     *
     * @param requestId Идентификатор обращения клиента (required)
     * @param content Прикрепляемый файл (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AttachedRequestAttachData uploadRequestAttachment(Long requestId, Resource content, long timeout) throws RestClientException {
        return uploadRequestAttachment(requestId, content).get(timeout);
    }

    /**
     * Прикрепить файл к обращению. асинхронно
     * POST /insurance-service/v2/client-request/temp/{requestId}/attachment
     *
     * @param requestId Идентификатор обращения клиента (required)
     * @param content Прикрепляемый файл (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AttachedRequestAttachData> uploadRequestAttachment(Long requestId, Resource content) throws RestClientException {
        return new ClientRestResult<>(uploadRequestAttachmentInternal(requestId, content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AttachedRequestAttachData>> uploadRequestAttachmentInternal(Long requestId, Resource content) throws RestClientException {
        if (requestId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "requestId", "uploadRequestAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/client-request/temp/{requestId}/attachment")).variable("requestId", requestId);

        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AttachedRequestAttachData>(){});
    }

    /**
     * Прикрепить файл к обращению клиента
     * POST /insurance-service/v2/client-request/temp/{requestId}/attachment/base64
     *
     * @param requestId Идентификатор обращения клиента (required)
     * @param attachment Данные о файле, прикрепляемом к обращению клиента. (required)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public AttachedRequestAttachData uploadRequestAttachmentBase64(Long requestId, AttachmentData attachment, long timeout) throws RestClientException {
        return uploadRequestAttachmentBase64(requestId, attachment).get(timeout);
    }

    /**
     * Прикрепить файл к обращению клиента асинхронно
     * POST /insurance-service/v2/client-request/temp/{requestId}/attachment/base64
     *
     * @param requestId Идентификатор обращения клиента (required)
     * @param attachment Данные о файле, прикрепляемом к обращению клиента. (required)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<AttachedRequestAttachData> uploadRequestAttachmentBase64(Long requestId, AttachmentData attachment) throws RestClientException {
        return new ClientRestResult<>(uploadRequestAttachmentBase64Internal(requestId, attachment), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<AttachedRequestAttachData>> uploadRequestAttachmentBase64Internal(Long requestId, AttachmentData attachment) throws RestClientException {
        if (requestId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "requestId", "uploadRequestAttachmentBase64"));
        if (attachment == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "attachment", "uploadRequestAttachmentBase64"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/client-request/temp/{requestId}/attachment/base64")).variable("requestId", requestId);

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(attachment);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<AttachedRequestAttachData>(){});
    }

    /**
     * Загрузить файл, прикреплённый к заявлению договора страхования.
     * POST /insurance-service/v2/contract/attachments/statements/{statementId}/{documentType}
     *
     * @param statementId Id заявления. (required)
     * @param documentType Идентификатор типа документа из справочника обязательных документов (required)
     * @param content Контент (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @throws RestClientException в случае неудачи
    */
    public Void uploadStatementAttachment(Long statementId, Long documentType, Resource content, long timeout) throws RestClientException {
        return uploadStatementAttachment(statementId, documentType, content).get(timeout);
    }

    /**
     * Загрузить файл, прикреплённый к заявлению договора страхования. асинхронно
     * POST /insurance-service/v2/contract/attachments/statements/{statementId}/{documentType}
     *
     * @param statementId Id заявления. (required)
     * @param documentType Идентификатор типа документа из справочника обязательных документов (required)
     * @param content Контент (optional)
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<Void> uploadStatementAttachment(Long statementId, Long documentType, Resource content) throws RestClientException {
        return new ClientRestResult<>(uploadStatementAttachmentInternal(statementId, documentType, content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<Void>> uploadStatementAttachmentInternal(Long statementId, Long documentType, Resource content) throws RestClientException {
        if (statementId == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "statementId", "uploadStatementAttachment"));
        if (documentType == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "documentType", "uploadStatementAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/attachments/statements/{statementId}/{documentType}")).variable("statementId", statementId).variable("documentType", documentType);

        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<Void>(){});
    }

    /**
     * Загрузить файл, прикреплённый к договору страхования.
     * POST /insurance-service/v2/contract/temp/{uuid}/attachment/{documentType}
     *
     * @param uuid uuid экземпляра договора страхования (required)
     * @param documentType Идентификатор из справочника обязательных документов (required)
     * @param content Контент (optional)
     * @param timeout таймаут ожидания ответа на асинхронный запрос
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public UuidRs uploadTempAttachment(String uuid, Long documentType, Resource content, long timeout) throws RestClientException {
        return uploadTempAttachment(uuid, documentType, content).get(timeout);
    }

    /**
     * Загрузить файл, прикреплённый к договору страхования. асинхронно
     * POST /insurance-service/v2/contract/temp/{uuid}/attachment/{documentType}
     *
     * @param uuid uuid экземпляра договора страхования (required)
     * @param documentType Идентификатор из справочника обязательных документов (required)
     * @param content Контент (optional)
     * @return 
     * @throws RestClientException в случае неудачи
    */
    public ClientRestResult<UuidRs> uploadTempAttachment(String uuid, Long documentType, Resource content) throws RestClientException {
        return new ClientRestResult<>(uploadTempAttachmentInternal(uuid, documentType, content), this::processStatusCodeErrors);
    }

    private ListenableFuture<ResponseEntity<UuidRs>> uploadTempAttachmentInternal(String uuid, Long documentType, Resource content) throws RestClientException {
        if (uuid == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "uuid", "uploadTempAttachment"));
        if (documentType == null)
            throw new RestClientException(String.format(REQUIRED_PARAM_ERROR, "documentType", "uploadTempAttachment"));
        

        MicroServiceURIBuilder uriBuilder = JmsUriBuilder.service(applicationName)
            .path(cutComments("/insurance-service/v2/contract/temp/{uuid}/attachment/{documentType}")).variable("uuid", uuid).variable("documentType", documentType);

        MultiValueMap<String, Object> multipartMap = new LinkedMultiValueMap<>();
        if (content != null){
           multipartMap.add("content", content);
        } 
        

        RequestEntity requestEntity = RequestEntity
                  .method(HttpMethod.POST, uriBuilder.build())
                  .body(multipartMap);
        return microServiceTemplate.exchange(requestEntity,
                    new ParameterizedTypeReference<UuidRs>(){});
    }
    private String cutComments(String path) {
        return path.split("#", 2)[0];
    }

    private void addPageableParams(MicroServiceURIBuilder builder, Pageable pageable) {
        if (pageable != null) {
            builder.param("page", pageable.getPageNumber());
            builder.param("size", pageable.getPageSize());
            Sort sort = pageable.getSort();
            if (sort != null) {
                List<String> sortParams = new ArrayList<>();
                for (Sort.Order next : sort) {
                    sortParams.add(next.getProperty());
                }
                sortParams.add(sort.getOrderFor(sortParams.get(0)).getDirection().name());
                builder.param("sort", String.join(",", sortParams));
            }
        }
    }

    private void processStatusCodeErrors(Exception e) throws RestClientException {
            HttpStatus statusCode = RestUtils.getStatusCode(e);
            if (statusCode != null) {
                switch (statusCode) {
                    case INTERNAL_SERVER_ERROR:
                        throw new RestClientException(String.format(STATUS_CODE_TEMPLATE, HttpStatus.INTERNAL_SERVER_ERROR.toString()));
                    case CONFLICT:
                        throw new EntityExistsException();
                    case NOT_FOUND:
                        throw new NotFoundException();
                }
            }
            throw new RestClientException(e.toString());
    }
}
